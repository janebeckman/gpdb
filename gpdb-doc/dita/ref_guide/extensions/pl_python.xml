<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="pw216155">Greenplum PL/Python Language Extension</title>
  <body>
    <p>This section contains an overview of the Greenplum Database PL/Python Language.</p>
    <ul>
      <li id="pw223311">
        <xref href="#topic2" type="topic" format="dita"/>
      </li>
      <li id="pw223326">
        <xref href="#topic4" type="topic" format="dita"/>
      </li>
      <li id="pw218889">
        <xref href="#topic7" type="topic" format="dita"/>
      </li>
      <li id="pw222281">
        <xref href="#topic10" type="topic" format="dita"/>
      </li>
      <li id="pw22228177">
        <xref href="#topic_pydatascimod" type="topic" format="dita"/>
      </li>
      <li id="pw21367233">
        <xref href="#topic_yx3_yjq_rt" type="topic" format="dita"/>
      </li>
      <li id="pw213672">
        <xref href="#topic11" type="topic" format="dita"/>
      </li>
      <li id="pw216139">
        <xref href="#topic12" type="topic" format="dita"/>
      </li>
    </ul>
  </body>
  <topic id="topic2" xml:lang="en">
    <title id="pw216140">About Greenplum PL/Python</title>
    <body>
      <p>PL/Python is a loadable procedural language. With the Greenplum Database PL/Python
        extension, you can write Greenplum Database user-defined functions or anonymous code blocks in Python that take
        advantage of Python features and modules to quickly build robust database applications. </p>
      <p>Greenplum Database provides a collection of data science-related Python
         modules that you can install and import in your UDFs. You can also build
         and install custom Python modules in your Greenplum Database cluster.</p>
    </body> 
    <topic id="topic3" xml:lang="en">
      <title>Greenplum Database PL/Python Limitations</title>
      <body>
        <ul id="ul_qhg_33m_zt">
          <li>Greenplum Database does not support PL/Python triggers.</li>
          <li>PL/Python is available only as a Greenplum Database untrusted language.</li>
          <li>Updatable cursors (<codeph>UPDATE...WHERE CURRENT OF</codeph> and
              <codeph>DELETE...WHERE CURRENT OF</codeph>) are not supported.</li>
        </ul>
      </body>
    </topic>
  </topic>
  <topic id="topic4" xml:lang="en">
    <title id="pw217326">Enabling and Removing PL/Python support</title>
    <body>
      <p>The PL/Python procedural language is installed with Greenplum Database. To create and run a PL/Python
        user-defined function (UDF) in a database, you must register the PL/Python language with the
        database. </p>
    </body>
    <topic id="topic_pythonverify" xml:lang="en">
      <title id="pw217326">Verifying Your Python Environment</title>
      <body>
        <p>When installed, Greenplum Database includes an embedded Python distribution. 
          The <codeph>gpadmin</codeph> user environment is configured to use this embedded Python.</p>
        <p>To verify the Python environment in your Greenplum Database installation, use the <codeph>which</codeph> command:</p>
          <codeblock>$ which python</codeblock>
        <p>The <codeph>which</codeph> command returns the path to the <codeph>python</codeph>
        executable currently in use in your environment. The Python installed with
        Greenplum Database is located in the <codeph>$GPHOME/ext/python</codeph> directory.</p>
      <codeblock>/<varname>path_to_greenplum-db</varname>/ext/python/bin/python</codeblock>
      </body>
    </topic>
    <topic id="topic5" xml:lang="en">
      <title>Enabling PL/Python Support</title>
      <body>
        <p>For each database that requires its use, register the PL/Python language with the SQL
          command <codeph>CREATE LANGUAGE</codeph> or the Greenplum Database utility
            <codeph>createlang</codeph>. Because PL/Python is an untrusted language, only superusers
          can register PL/Python with a database. For example, running this command as the
            <codeph>gpadmin</codeph> system user registers PL/Python with the database named
            <codeph>testdb</codeph>:</p>
        <codeblock>$ createlang plpythonu -d testdb</codeblock>
        <p>PL/Python is registered as an untrusted language.</p>
      </body>
    </topic>
    <topic id="topic6" xml:lang="en">
      <title>Removing PL/Python Support</title>
      <body>
        <p>For a database that no longer requires the PL/Python language, remove support for
          PL/Python with the SQL command <codeph>DROP LANGUAGE</codeph> or the Greenplum Database
            <codeph>droplang</codeph> utility. Because PL/Python is an untrusted language, only
          superusers can remove support for the PL/Python language from a database. For example,
          running this command as the <codeph>gpadmin</codeph> system user removes support for
          PL/Python from the database named <codeph>testdb</codeph>:</p>
        <codeblock>$ droplang plpythonu -d testdb</codeblock>
        <p>When you remove support for PL/Python, the PL/Python user-defined functions that you
          created in the database will no longer work. </p>
      </body>
    </topic>
  </topic>
  <topic id="topic7" xml:lang="en">
    <title id="pw218204">Developing Functions with PL/Python</title>
    <body>
      <p>The body of a PL/Python user-defined function is a Python script. When the function is
        called, its arguments are passed as elements of the array <codeph>args[]</codeph>. Named
        arguments are also passed as ordinary variables to the Python script. The result is returned
        from the PL/Python function with <codeph>return</codeph> statement, or
          <codeph>yield</codeph> statement in case of a result-set statement. </p>
    </body>
  <topic id="topic1113" xml:lang="en">
    <title id="pw2137121113">Arrays and Lists</title>
    <body>
      <p>You pass SQL array values into PL/Python functions with a Python list. Similarly, PL/Python functions return SQL array values as a Python list. In the typical PL/Python usage pattern, you will specify an array with <codeph>[]</codeph>.</p>

<p>The following example creates a PL/Python function that returns an array of integers:</p>
<codeblock>CREATE FUNCTION return_py_int_array()
  RETURNS int[]
AS $$
  return [1, 11, 21, 31]
$$ LANGUAGE plpythonu;

SELECT return_py_int_array();
 return_py_int_array 
---------------------
 {1,11,21,31}
(1 row) </codeblock>

<p>PL/Python treats multi-dimensional arrays as lists of lists. You pass a multi-dimensional array to a PL/Python function using nested Python lists. When a PL/Python function returns a multi-dimensional array, the inner lists at each level must all be of the same size. </p>

<p>The following example creates a PL/Python function that takes a multi-dimensional array of integers as input. The function displays the type of the provided argument, and returns the multi-dimensional array:</p>
<codeblock>CREATE FUNCTION return_multidim_py_array(x int4[]) 
  RETURNS int4[]
AS $$
  plpy.info(x, type(x))
  return x
$$ LANGUAGE plpythonu;

SELECT * FROM return_multidim_py_array(ARRAY[[1,2,3], [4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
CONTEXT:  PL/Python function "return_multidim_py_type"
 return_multidim_py_array 
--------------------------
 {{1,2,3},{4,5,6}}
(1 row) </codeblock>

<p>PL/Python also accepts other Python sequences, such as tuples, as function arguments for backwards compatibility with Greenplum versions where multi-dimensional arrays were not supported. In such cases, the Python sequences are always treated as one-dimensional arrays because they are ambiguous with composite types.</p>
    </body>
  </topic>
  <topic id="topic1117" xml:lang="en">
    <title id="pw2137121117">Composite Types</title>
    <body>
<p>You pass composite-type arguments to a PL/Python function using Python mappings. The element names of the mapping are the attribute names of the composite types. If an attribute has the null value, its mapping value is <codeph>None</codeph>.</p>
<p>You can return a composite type result as a sequence type (tuple or list).
You must specify a composite type as a tuple, rather than a list, when it is used in a multi-dimensional array. You cannot return an array of composite types as a list because it would be ambiguous to determine whether the list represents a composite type or another array dimension. In the typical usage pattern, you will specify composite type tuples with <codeph>()</codeph>.</p>

<p>In the following example, you create a composite type and a PL/Python function that returns an array of the composite type:</p>
<codeblock>CREATE TYPE type_record AS (
  first text,
  second int4
);

CREATE FUNCTION composite_type_as_list()
  RETURNS type_record[]
AS $$              
  return [[('first', 1), ('second', 1)], [('first', 2), ('second', 2)], [('first', 3), ('second', 3)]];
$$ LANGUAGE plpythonu;

SELECT * FROM composite_type_as_list();
                               composite_type_as_list                           
------------------------------------------------------------------------------------
 {{"(first,1)","(second,1)"},{"(first,2)","(second,2)"},{"(first,3)","(second,3)"}}
(1 row) </codeblock>
    <p>Refer to the PostgreSQL <xref href="https://www.postgresql.org/docs/devel/static/plpython-data.html#plpython-arrays" scope="external" format="html">Arrays, Lists</xref> documentation for additional information on PL/Python handling of arrays and composite types.</p>
    </body>
  </topic>

    <topic id="topic8" xml:lang="en">
      <title>Executing and Preparing SQL Queries </title>
      <body>
        <p>The PL/Python <codeph>plpy</codeph> module provides two Python functions to execute an
          SQL query and prepare an execution plan for a query, <codeph>plpy.execute</codeph> and
            <codeph>plpy.prepare</codeph>. Preparing the execution plan for a query is useful if you
          run the query from multiple Python functions.</p>
      </body>
      <topic id="topic_jnf_45f_zt">
        <title>plpy.execute</title>
        <body>
          <p>Calling <codeph>plpy.execute</codeph> with a query string and an optional limit
            argument causes the query to be run and the result to be returned in a Python result
            object. The result object emulates a list or dictionary object. The rows returned in the
            result object can be accessed by row number and column name. The result set row
            numbering starts with 0 (zero). The result object can be modified. The result object has
            these additional methods: <ul id="ul_z5f_45f_zt">
              <li><codeph>nrows</codeph> that returns the number of rows returned by the query.</li>
              <li><codeph>status</codeph> which is the <codeph>SPI_execute()</codeph> return
                value.</li>
            </ul></p>
          <p>For example, this Python statement in a PL/Python user-defined function executes a
            query. </p>
          <codeblock>rv = plpy.execute("SELECT * FROM my_table", 5)</codeblock>
          <p>The <codeph>plpy.execute</codeph> function returns up to 5 rows from
              <codeph>my_table</codeph>. The result set is stored in the <codeph>rv</codeph> object.
            If <codeph>my_table</codeph> has a column <codeph>my_column</codeph>, it would be
            accessed as:</p>
          <codeblock>my_col_data = rv[i]["my_column"]</codeblock>
          <p>Since the function returns a maximum of 5 rows, the index <varname>i</varname> can be
            an integer between 0 and 4.</p>
        </body>
      </topic>
      <topic id="topic_jwf_p5f_zt">
        <title>plpy.prepare</title>
        <body>
          <p>The function <codeph>plpy.prepare</codeph> prepares the execution plan for a query. It
            is called with a query string and a list of parameter types, if you have parameter
            references in the query. For example, this statement can be in a PL/Python user-defined
            function:</p>
          <codeblock>plan = plpy.prepare("SELECT last_name FROM my_users WHERE 
  first_name = $1", [ "text" ])</codeblock>
          <p>The string <codeph>text</codeph> is the data type of the variable that is passed for
            the variable <varname>$1</varname>. After preparing a statement, you use the function
              <codeph>plpy.execute</codeph> to run it:</p>
          <codeblock>rv = plpy.execute(plan, [ "Fred" ], 5)</codeblock>
          <p>The third argument is the limit for the number of rows returned and is optional.</p>
          <p>When you prepare an execution plan using the PL/Python module the plan is automatically
            saved. See the Postgres Server Programming Interface (SPI) documentation for information
            about the execution plans <xref
              href="https://www.postgresql.org/docs/8.3/static/spi.html" scope="external"
              format="html">https://www.postgresql.org/docs/8.3/static/spi.html</xref>.</p>
          <p>To make effective use of saved plans across function calls you use one of the Python
            persistent storage dictionaries SD or GD. </p>
          <p>The global dictionary SD is available to store data between function calls. This
            variable is private static data. The global dictionary GD is public data, available to
            all Python functions within a session. Use GD with care.</p>
          <p>Each function gets its own execution environment in the Python interpreter, so that
            global data and function arguments from <codeph>myfunc</codeph> are not available to
              <codeph>myfunc2</codeph>. The exception is the data in the GD dictionary, as mentioned
            previously.</p>
          <p>This example uses the SD dictionary:</p>
          <codeblock>CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
  if SD.has_key("plan"):
    plan = SD["plan"]
  else:
    plan = plpy.prepare("SELECT 1")
    SD["plan"] = plan

  # rest of function

$$ LANGUAGE plpythonu;</codeblock>
        </body>
      </topic>
  </topic>
    <topic id="topic_s3d_vc4_xt">
      <title>Handling Python Errors and Messages</title>
      <body>
        <p> The Python module <codeph>plpy</codeph> implements these functions to manage errors and messages:</p>
          <ul id="ul_fp4_jq5_xt">
              <li><codeph>plpy.debug</codeph></li>
              <li><codeph>plpy.log</codeph></li>
              <li><codeph>plpy.info</codeph></li>
              <li><codeph>plpy.notice</codeph></li>
              <li><codeph>plpy.warning</codeph></li>
              <li><codeph>plpy.error</codeph></li>
              <li><codeph>plpy.fatal</codeph></li>
              <li><codeph>plpy.debug</codeph></li>
          </ul>
        <p>The message functions <codeph>plpy.error</codeph> and <codeph>plpy.fatal</codeph> raise a
          Python exception which, if uncaught, propagates out to the calling query, causing the
          current transaction or subtransaction to be aborted. The functions <codeph>raise
            plpy.ERROR(msg)</codeph> and <codeph>raise plpy.FATAL(msg)</codeph> are equivalent to
          calling <codeph>plpy.error</codeph> and <codeph>plpy.fatal</codeph>, respectively. The
          other message functions only generate messages of different priority levels. </p>
        <p>Whether messages of a particular priority are reported to the client, written to the
          server log, or both is controlled by the Greenplum Database server configuration
          parameters <codeph>log_min_messages</codeph> and <codeph>client_min_messages</codeph>. For
          information about the parameters see the <cite>Greenplum Database Reference
          Guide</cite>.</p>
      </body>
    </topic>
    <topic id="topic9" xml:lang="en">
      <title>Using the dictionary GD To Improve PL/Python Performance</title>
      <body>
        <p>In terms of performance, importing a Python module is an expensive operation and can
          affect performance. If you are importing the same module frequently, you can use Python
          global variables to load the module on the first invocation and not require importing the
          module on subsequent calls. The following PL/Python function uses the GD persistent
          storage dictionary to avoid importing a module if it has already been imported and is in
          the GD. </p>
        <codeblock>psql=#
   CREATE FUNCTION pytest() returns text as $$ 
      if 'mymodule' not in GD:
        import mymodule
        GD['mymodule'] = mymodule
    return GD['mymodule'].sumd([1,2,3])
$$;</codeblock>
      </body>
    </topic>
  </topic>
  <topic id="topic10" xml:lang="en">
    <title id="pw221333">Python Modules</title>
    <body>
      <p> A Python module is a text file containing Python statements and definitions. Python modules are named, with the file name for a module following the <codeph><varname>python-module-name</varname>.py</codeph> naming convention. You can import Python modules into user-defined functions that you create with PL/Python.  </p>
      <p> Greenplum Database provides a collection of data science-related Python modules that you can install and import into your UDFs. You can also build and install custom Python modules in your Greenplum Database cluster.  </p>
    </body>
  </topic>

  <topic id="topic_pydatascimod">
    <title>Python Data Science Module Package</title>
    <body>
     <p> Greenplum Database provides a collection of data science-related Python modules. You can <ph otherprops="oss-only">build these modules in <codeph>.gppkg</codeph> format</ph> <ph otherprops="pivotal">download these modules in <codeph>.gppkg</codeph> format from <xref href="https://network.pivotal.io/products/pivotal-gpdb" format="html" scope="external">Pivotal Network</xref></ph>.
       <table id="iq1395577">
          <title>Data Science Modules</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="col1" colwidth="1*"/>
            <colspec colnum="2" colname="col2" colwidth="2*"/>
            <thead>
              <row>
                <entry colname="col1">Module Name</entry>
                <entry colname="col2">Description/Used For</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="col1">
                  Beautiful Soup
                </entry>
                <entry colname="col2">Navigating HTML and XML</entry>
              </row>
              <row>
                <entry colname="col1">
                  Gensim
                </entry>
                <entry colname="col2">Topic modeling and document indexing</entry>
              </row>
              <row>
                <entry colname="col1">
                  Keras
                </entry>
                <entry colname="col2">Deep learning</entry>
              </row>
              <row>
                <entry colname="col1">
                  Lifelines
                </entry>
                <entry colname="col2">Survival analysis</entry>
              </row>
              <row>
                <entry colname="col1">
                  lxml
                </entry>
                <entry colname="col2">XML and HTML processing</entry>
              </row>
              <row>
                <entry colname="col1">
                  NLTK
                </entry>
                <entry colname="col2">Natural language toolkit</entry>
              </row>
              <row>
                <entry colname="col1">
                  NumPy
                </entry>
                <entry colname="col2">Scientific computing</entry>
              </row>
              <row>
                <entry colname="col1">
                  Pandas
                </entry>
                <entry colname="col2">Data analysis</entry>
              </row>
              <row>
                <entry colname="col1">
                  Pattern-en
                </entry>
                <entry colname="col2">Part-of-speech tagging</entry>
              </row>
              <row>
                <entry colname="col1">
                  pyLDAvis
                </entry>
                <entry colname="col2">Interactive topic model visualization</entry>
              </row>
              <row>
                <entry colname="col1">
                  PyMC3
                </entry>
                <entry colname="col2">Statistical modeling and probabilistic machine learning</entry>
              </row>
              <row>
                <entry colname="col1">
                  scikit-learn
                </entry>
                <entry colname="col2">Machine learning data mining and analysis</entry>
              </row>
              <row>
                <entry colname="col1">
                  SciPy
                </entry>
                <entry colname="col2">Scientific computing</entry>
              </row>
              <row>
                <entry colname="col1">
                  spaCy
                </entry>
                <entry colname="col2">Large scale natural language processing</entry>
              </row>
              <row>
                <entry colname="col1">
                  StatsModels
                </entry>
                <entry colname="col2">Statistical modeling</entry>
              </row>
              <row>
                <entry colname="col1">
                  Tensorflow
                </entry>
                <entry colname="col2">Numerical computation using data flow graphs</entry>
              </row>
              <row>
                <entry colname="col1">
                  XGBoost
                </entry>
                <entry colname="col2">Gradient boosting, classifying, ranking </entry>
              </row>
            </tbody>
          </tgroup>
        </table></p>
    </body> 
    <topic id="topic_instpdsm" xml:lang="en">
      <title>Installing the Python Data Science Module Package</title>
      <body>
        <p>Before you install the Python Data Science Module package, make sure that your Greenplum Database is running, you have sourced <codeph>greenplum_path.sh</codeph>, and that the <codeph>$MASTER_DATA_DIRECTORY</codeph> and <codeph>$GPHOME</codeph> environment variables are set.</p>
        <ol>
          <li>Locate the Python Data Science module package that you built or downloaded.<p>The file name format of the package is <codeph>DataSciencePython-&lt;version&gt;-relhel&lt;N&gt;-x86_64.gppkg</codeph>.</p></li>
          <li>Copy the package to the Greenplum Database master host.</li>
          <li>Use the <codeph>gppkg</codeph> command to install the package. For example:<codeblock>$ gppkg -i DataSciencePython-&lt;version&gt;-relhel&lt;N&gt;-x86_64.gppkg</codeblock><p><codeph>gppkg</codeph> installs the Python Data Science modules on all nodes in your Greenplum Database cluster. The command also updates the <codeph>PYTHONPATH</codeph>, <codeph>PATH</codeph>, and <codeph>LD_LIBRARY_PATH</codeph> environment variables in your <codeph>greenplum_path.sh</codeph> file.</p></li>
          <li>Restart Greenplum Database. You must re-source <codeph>greenplum_path.sh</codeph> before restarting your Greenplum cluster:<codeblock>$ source /usr/local/greenplum-db/greenplum_path.sh
$ gpstop -r</codeblock></li>
        </ol>
       <p>The Greenplum Database Python Data Science Modules are installed in the following directory:</p><codeblock>$GPHOME/ext/DataSciencePython/lib/python2.7/site-packages/</codeblock>
      </body>
    </topic>
    <topic id="topic_removepdsm" xml:lang="en">
      <title>Uninstalling the Python Data Science Module Package</title>
      <body>
        <p>Use the <codeph>gppkg</codeph> utility to uninstall the Python Data Science Module package. You must include the version number in the package name you provide to <codeph>gppkg</codeph>.</p>
        <p> To determine your Python Data Science Module package version number and remove this package:</p>
        <codeblock>$ gppkg -q --all | grep DataSciencePython
DataSciencePython-&lt;version&gt;
$ gppkg -r DataSciencePython-&lt;version&gt;</codeblock>
        <p>The command removes the Python Data Science modules from your Greenplum Database cluster. It also updates the <codeph>PYTHONPATH</codeph>, <codeph>PATH</codeph>, and <codeph>LD_LIBRARY_PATH</codeph> environment variables in your <codeph>greenplum_path.sh</codeph> file to their pre-installation values.</p>
        <p>Re-source <codeph>greenplum_path.sh</codeph> and restart Greenplum Database after you remove the Python Data Science Module package:</p>
        <codeblock>$ . /usr/local/greenplum-db/greenplum_path.sh
$ gpstop -r </codeblock>
        <note>When you uninstall the Python Data Science Module package from your Greenplum Database cluster, any UDFs that you have created that import Python modules installed with this package will return an error.</note>
      </body>
    </topic>
  </topic>
        
  <topic id="topic_yx3_yjq_rt">
    <title>Building/Installing Custom Python Modules</title>
    <body>
      <p>You can build a Python module on a host system outside of your Greenplum Database cluster
        and later install the built module on all cluster hosts. Before building a Python
        module, ensure that the appropriate software build dependencies
        are installed and properly configured on the build system and that the build
        generates the correct executable. For example, on a Linux system the build
        should create a 64-bit executable.</p>
      <note>Some Python modules require installing additional software, such as a third party library or a compiler. Refer to the Python module's documentation for information about the requirements for building and using the module.</note>
      <p>When you install a custom Python module in Greenplum Database, you must add the module to
        all segment and mirror hosts in the cluster. When you expand Greenplum Database, you
        must add the Python modules to the new segment hosts. You can use the Greenplum Database
        utilities <codeph>gpssh</codeph> and <codeph>gpscp</codeph> to run commands on,
        and copy files to, remote Greenplum Database hosts.</p>
      <p>Python module examples in this section include:<ul id="ul_ukh_4wr_wt">
          <li><xref href="#topic_pycustombldinst" format="dita"/></li>
          <li><xref href="#topic_e4p_gcw_vt" format="dita"/></li>
          <li><xref href="#topic_troubleshoot_pymodimp" format="dita"/></li>
        </ul></p>
      </body>
    <topic id="topic_pycustombldinst">
    <title>Building/Installing a Simple Python Module (setuptools)</title>
      <body>
        <p><codeph>setuptools</codeph> is a Python module that enables you to easily
          download, build, install, upgrade, and uninstall Python packages. <codeph>setuptools</codeph> 
          is available from the Python Package Index repository.</p>
        <p>In this example, you will build the <codeph>setuptools</codeph> module from the
          download package and install it on a single host. You will then build and install 
          the module on all segment hosts in your Greenplum Database cluster.</p>
        <ol id="ol_orb_3pq_rt">
          <li>(Optional) Create a work directory:
             <codeblock>$ mkdir plpython_pkgs
$ cd plpython_pkgs</codeblock></li>
          <li>Download the <codeph>setuptools</codeph> module package from the Python
             Package Index site. For example, run this <codeph>wget</codeph> command on
             a Greenplum Database host as the <codeph>gpadmin</codeph> user:
            <codeblock>$ wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-18.4.tar.gz</codeblock></li>
          <li>Extract the files from the <codeph>.tar.gz</codeph> package:
            <codeblock>$ tar xzvf setuptools-18.4.tar.gz</codeblock></li>
          <li>Run the Python scripts to build and install the Python <codeph>setuptools</codeph>
            package:
           <codeblock>$ cd setuptools-18.4
$ python setup.py build
$ python setup.py install</codeblock><p>The package is installed to the location specified by the <codeph>$PYTHONPATH</codeph> environment variable.</p></li>
          <li>Run the following command to verify that the module is available to Python:
            <codeblock>$ python -c "import setuptools"</codeblock>
            <p>If no error is returned, the <codeph>setuptools</codeph> module was
            successfully imported.</p></li>
          <li>The <codeph>setuptools</codeph> package installs the <codeph>easy_install</codeph> utility. This utility enables you to install Python packages from the Python Package Index repository. The following command installs the Python <codeph>pip</codeph> utility from the Python Package Index site:
            <codeblock>$ easy_install pip</codeblock></li>
          <li>Copy the <codeph>setuptools</codeph> source package to all Greenplum Database
            hosts in your cluster. For example, this command uses the <codeph>gpscp</codeph>
            utility to copy the <codeph>.tar.gz</codeph> file from the current host to 
            the <codeph>/home/gpadmin</codeph> directory on all hosts listed in
            the file <codeph>remote-hosts</codeph>.<codeblock>$ gpscp -f remote-hosts setuptools-18.4.tar.gz =:/home/gpadmin</codeblock></li>
          <li>Run the following commands to build, install, and test the <codeph>setuptools</codeph>
            package on each host to which you copied the <codeph>.tar.gz</codeph> file:
            <codeblock>$ gpssh -f remote_hosts
>>> tar xzvf ../setuptools-18.4.tar.gz
>>> cd setuptools-18.4
>>> python setup.py build
>>> python setup.py install
>>> python -c "import setuptools"
>>> exit</codeblock><p>Alternatively, you could copy the built Python module files to each Greenplum Database host.</p></li>
        </ol>
      </body>
    </topic>
    <topic id="topic_e4p_gcw_vt">
      <title>Testing Installed Python Modules</title>
      <body>
        <p>You can create a simple PL/Python user-defined function (UDF) to validate that a Python
          module is available in Greenplum Database. This example tests the NumPy module 
          installed with the Python Data Science Module package:</p>
       <ol>
         <li>Create a PL/Python UDF that imports the NumPy module.
        <codeblock>CREATE OR REPLACE FUNCTION test_importnumpy(x int)
RETURNS text
AS $$
  try:
      from numpy import *
      return 'SUCCESS'
  except ImportError, e:
      return 'FAILURE'
$$ LANGUAGE plpythonu;</codeblock>
        <p>The function returns <codeph>SUCCESS</codeph> if the module is imported,
          and <codeph>FAILURE</codeph> if an import error occurs.</p></li>
        <li>Create a table that loads data on each Greenplum Database segment instance. 
        <codeblock>CREATE TABLE disttbl AS (SELECT x FROM generate_series(1,50) x ) DISTRIBUTED BY (x);</codeblock>
        <p>Depending upon the size of your Greenplum Database installation, you may need
          to generate a larger series to ensure that data is distributed to all segment instances.</p></li>
        <li>Run the UDF on the segment nodes where data is stored in the primary segment instances:
        <codeblock>SELECT gp_segment_id, test_importnumpy(x) AS status
  FROM disttbl
  GROUP BY gp_segment_id, status
  ORDER BY gp_segment_id, status;</codeblock>
        <p>The <codeph>SELECT</codeph> command returns <codeph>SUCCESS</codeph> if the
          UDF successfully imported the Python module on the Greenplum Database segment
          instance. If the <codeph>SELECT</codeph> command returns <codeph>FAILURE</codeph>,
          you can determine the hostname of the failed segment instance by querying the
          Greenplum Database system table named <codeph>gp_segment_configuration</codeph>.</p>
        <p>The following command returns the host name for a given segment ID:</p>
         <codeblock>SELECT hostname, content AS seg_ID FROM gp_segment_configuration
  WHERE content = <varname>seg_id</varname> ;</codeblock></li>
        </ol>
      </body>
    </topic>

    <topic id="topic_troubleshoot_pymodimp">
      <title>Troubleshooting Python Module Import Failures</title>
      <body>
        <p>Possible causes of a Python module import failure could include:
        <ul id="ul_mod_import_fail">
          <li>A problem accessing required libraries. For the NumPy example, Greenplum Database
            might have a problem accessing the Python libraries on a
            segment host.<p><i>Try</i>: Test importing the module directly on the
            segment host. The following <codeph>gpssh</codeph> command tests importing
              the NumPy module on the segment host named
              <codeph>mdw1</codeph>.<codeblock>$ gpssh -h mdw1 -e 'python -c "import numpy"'</codeblock></p></li>
          <li>Environment variables may not be configured in the Greenplum Database environment. The Python <codeph>import</codeph> statement may not return an error in this case. <p><i>Try</i>: Ensure that any environment variables that are required by a module are properly set in <codeph>gpadmin</codeph>'s <codeph>.bashrc</codeph> file on every host in your Greenplum Database cluster.</p></li>
          <li>Greenplum Database may not have been restarted after adding environment variable settings to the <codeph>.bashrc</codeph> file. Again, the Python <codeph>import</codeph> statement may not return an error in this case.<p><i>Try</i>: Ensure that you have restarted Greenplum Database after you make any updates to <codeph>gpadmin</codeph>'s <codeph>.bashrc</codeph>.</p><note>The <codeph>.bashrc</codeph> file for the <codeph>gpadmin</codeph> user must source <codeph>$GPHOME/greenplum_path.sh</codeph> on all Greenplum Database master and segment hosts.</note></li>
        </ul></p>
      </body>
    </topic>
  </topic>

  <topic id="topic11" xml:lang="en">
    <title id="pw213712">Examples</title>
    <body>
      <p>This PL/Python UDF returns the maximum of two integers:</p>
      <codeblock>CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
      return None
  if a > b:
     return a
  return b
$$ LANGUAGE plpythonu;</codeblock>
      <p>You can use the <codeph>STRICT</codeph> property to perform the null handling instead of
        using the two conditional statements.</p>
      <codeblock>CREATE FUNCTION pymax (a integer, b integer) 
  RETURNS integer AS $$ 
return max(a,b) 
$$ LANGUAGE plpythonu STRICT ;</codeblock>
      <p>You can run the user-defined function <codeph>pymax</codeph> with <codeph>SELECT</codeph>
        command. This example runs the UDF and shows the output.</p>
      <codeblock>SELECT ( pymax(123, 43));
column1
---------
     123
(1 row)</codeblock>
      <p>This example that returns data from an SQL query that is run against a table. These two
        commands create a simple table and add data to the table.</p>
      <codeblock>CREATE TABLE sales (id int, year int, qtr int, day int, region text)
  DISTRIBUTED BY (id) ;

INSERT INTO sales VALUES
 (1, 2014, 1,1, 'usa'),
 (2, 2002, 2,2, 'europe'),
 (3, 2014, 3,3, 'asia'),
 (4, 2014, 4,4, 'usa'),
 (5, 2014, 1,5, 'europe'),
 (6, 2014, 2,6, 'asia'),
 (7, 2002, 3,7, 'usa') ;</codeblock>
      <p>This PL/Python UDF executes a <codeph>SELECT</codeph> command that returns 5 rows from the
        table. The Python function returns the <codeph>REGION</codeph> value from the row specified
        by the input value. In the Python function, the row numbering starts from 0. Valid input for
        the function is an integer between 0 and 4. </p>
      <codeblock>CREATE OR REPLACE FUNCTION mypytest(a integer) 
  RETURNS text 
AS $$ 
  rv = plpy.execute("SELECT * FROM sales ORDER BY id", 5)
  region = rv[a]["region"]
  return region
$$ language plpythonu;</codeblock>
      <p>Running this <codeph>SELECT</codeph> statement returns the <codeph>REGION</codeph> column
        value from the third row of the result set.</p>
      <codeblock>SELECT mypytest(2) ;</codeblock>
      <p>This command deletes the UDF from the database.</p>
      <codeblock>DROP FUNCTION mypytest(integer) ;</codeblock>
      <p>This example executes the PL/Python function in the previous example as an anonymous block
        with the <codeph>DO</codeph> command. In the example, the anonymous block retrieves the
        input value from a temporary table.</p>
      <codeblock>CREATE TEMP TABLE mytemp AS VALUES (2) DISTRIBUTED RANDOMLY;

DO $$ 
  temprow = plpy.execute("SELECT * FROM mytemp", 1)
  myval = temprow[0]["column1"]
  rv = plpy.execute("SELECT * FROM sales ORDER BY id", 5)
  region = rv[myval]["region"]
  plpy.notice("region is %s" % region)
$$ language plpythonu;</codeblock>
    </body>
  </topic>
  <topic id="topic12" xml:lang="en">
    <title>Technical References</title>
    <body>
      <p>For information about the Python language, see <xref href="https://www.python.org/"
        scope="external" format="html">https://www.python.org/</xref>.</p>
      <p>For information about PL/Python see the PostgreSQL documentation at <xref
        href="https://www.postgresql.org/docs/8.3/static/plpython.html" scope="external"
        format="html">https://www.postgresql.org/docs/8.3/static/plpython.html</xref>.</p>
      <p>For information about Python Package Index (PyPI), see <xref
        href="https://pypi.python.org/pypi" format="html" scope="external">https://pypi.python.org/pypi</xref>.</p>
    </body>
  </topic>
</topic>
